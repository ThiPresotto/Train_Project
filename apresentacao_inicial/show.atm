set SDL = require "SDL"
set IMG = require "SDL.image"
set TTF = require "SDL.ttf"
set MIX = require "SDL.mixer"


set sdl = require "atmos.env.sdl"


SDL.init(SDL.flags.video) -->assert
TTF.init() -->assert
IMG.init() -->assert 
MIX.init() -->assert

MIX.openAudio(44100, SDL.audioFormat.S16, 2, 1024) --> assert

;;;
val mode = SDL.getCurrentDisplayMode(0)
val W = mode.w
val H = mode.h
;;;

var slide = 1

defer{
    SDL.quit()
    TTF.quit()
    IMG.quit()
    MIX.quit()
}


val WIN = SDL.createWindow @{
    title = "Apresentação",
    height = 1000,
    width = 1500,
    flags = @{ SDL.flags.OpenGL
    }
} --> assert

set REN = SDL.createRenderer(WIN, -1) --> assert
set sdl.ren = REN

spawn{
    val FNT1 = TTF.open("TPF Krikkel Krakkel.ttf",280) --> assert
    val FNT2 = TTF.open("DejaVuSans.ttf",40)-->assert
    every :sdl.draw{
        match slide{
            1=>{
                REN::setDrawColor(0x777777)
                set Rectd = @{x=0,y=0,w=1500,h=1000}
                REN::fillRect(Rectd)
                ;;set Rectd = @{x=((1500/2)-(img_w/2)),y=((1000/2)-(img_h/2)),w = img_w,h=img_h}
                val img_1 = tex where {
                    sfc = IMG.load("../Infinigma-Train.png") --> assert
                    tex = REN::createTextureFromSurface(sfc) --> assert
                }
                val img_2 = tex where {
                    sfc = IMG.load("../ghost_train.png") --> assert
                    tex = REN::createTextureFromSurface(sfc) --> assert
                }
                val img_3 = tex where {
                    sfc = IMG.load("Rail.png") -->assert
                    tex = REN::createTextureFromSurface(sfc) -->assert
                }
                val _,_,img_w,img_h = img_1::query()
                set Rectd = @{x=((1500/2)-(1192/2)),y=(1000/2)-250,w=1192,h=670}
                REN::copy(img_2,nil,Rectd)
                set Rectd = @{x=0,y=(1000/2)-570,w = img_w-50,h=img_h}
                REN::copy(img_1,nil,Rectd)
                set Rectd = @{x=970,y=150,w = 10,h=10}
                sdl.write(FNT1,"INFIGMA",Rectd) 
                set Rects=@{x=0,y=200,w=1024,h=1000}
                REN::copy(img_3,Rects,@{x=0,y=0,w=100,h=100}) 
                REN::copy(img_3,Rects,@{x=0,y=100,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=200,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=300,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=400,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=500,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=600,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=700,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=800,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=900,w=100,h=100})      
                REN::copy(img_3,Rects,@{x=1400,y=0,w=100,h=100}) 
                REN::copy(img_3,Rects,@{x=1400,y=100,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=200,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=300,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=400,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=500,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=600,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=700,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=800,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=900,w=100,h=100})         
            }
            2=>{
                val img_1 = tex where {
                    sfc = IMG.load("../Infinigma-Train.png") --> assert
                    tex = REN::createTextureFromSurface(sfc) --> assert
                }
                val img_2 = tex where{
                    sfc = IMG.load("aurora.png")
                    tex = REN::createTextureFromSurface(sfc)
                }
                val img_3 = tex where {
                    sfc = IMG.load("Rail.png") -->assert
                    tex = REN::createTextureFromSurface(sfc) -->assert
                } 
                REN::copy(img_2,nil,@{x=0,y=0,w=1500,h=1200})
                val _,_,img_w,img_h = img_1::query()
                REN::copy(img_1,nil,@{x=80,y=230,w = img_w-50,h=img_h})
                set Rects=@{x=0,y=200,w=1024,h=1000}
                REN::copy(img_3,Rects,@{x=0,y=0,w=100,h=100}) 
                REN::copy(img_3,Rects,@{x=0,y=100,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=200,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=300,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=400,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=500,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=600,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=700,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=800,w=100,h=100})
                REN::copy(img_3,Rects,@{x=0,y=900,w=100,h=100})      
                REN::copy(img_3,Rects,@{x=1400,y=0,w=100,h=100}) 
                REN::copy(img_3,Rects,@{x=1400,y=100,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=200,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=300,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=400,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=500,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=600,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=700,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=800,w=100,h=100})
                REN::copy(img_3,Rects,@{x=1400,y=900,w=100,h=100}) 
                ;;;
                val text = tex where {
                    sfc = TTF::renderText("ola",solid, 0xFFFFFF, 0x777777)-->assert
                    tex = createTextureFromSurface(sfc)-->assert
                }
                REN::copy(text,nil,@{x=200,y=200,w=100,h=10})
                ;;;

                var tex1 = tex where{
                    sfc = (FNT2::renderUtf8("QUAL O PROJETO?","blended",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                REN::copy(tex1,nil,@{x=500,y=40,w=470,h=120})

                var tex1 = tex where{
                    sfc = (FNT2::renderUtf8("Infigma é um jogo curto de","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("Infigma é um jogo curto de")
                REN::copy(tex1,nil,@{x=630,y=200,w=tw,h=th})
                
                set tex1 = tex where{
                    sfc = (FNT2::renderUtf8("puzzle no qual o objetivo é descobrir","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("puzzle no qual o objetivo é descobrir")
                REN::copy(tex1,nil,@{x=630,y=200+th,w=tw,h=th})

                set tex1 = tex where{
                    sfc = (FNT2::renderUtf8("a resposta final do enigma do trem","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("a resposta final do enigma do trem")
                REN::copy(tex1,nil,@{x=630,y=200+(2*th),w=tw,h=th})

                set tex1 = tex where{
                    sfc = (FNT2::renderUtf8("infinito","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("infinito")
                REN::copy(tex1,nil,@{x=630,y=200+(3*th),w=tw,h=th})

                set tex1 = tex where{
                    sfc = (FNT2::renderUtf8("A proposta é de interagir com","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("A proposta é de interagir com")
                REN::copy(tex1,nil,@{x=630,y=430,w=tw,h=th})

                set tex1 = tex where{
                    sfc = (FNT2::renderUtf8("o cenário, buscar pistas e deduzir","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("o cenário, buscar pistas e deduzir")
                REN::copy(tex1,nil,@{x=630,y=430+th,w=tw,h=th})

                set tex1 = tex where{
                    sfc = (FNT2::renderUtf8("as respostas. É importante que todo","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("as respostas. É importante que todo")
                REN::copy(tex1,nil,@{x=630,y=430+(th*2),w=tw,h=th})

                set tex1 = tex where{
                    sfc = (FNT2::renderUtf8("conhecimento necessário se encontre","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("conhecimento necessário se encontre")
                REN::copy(tex1,nil,@{x=630,y=430+(th*3),w=tw,h=th})

                set tex1 = tex where{
                    sfc = (FNT2::renderUtf8("dentro do jogo.","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("dentro do jogo.")
                REN::copy(tex1,nil,@{x=630,y=430+(th*4),w=tw,h=th})

                set tex1 = tex where{
                    sfc = (FNT2::renderUtf8("A interação ocorrerá por elementos","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("A interação ocorrerá por elementos")
                REN::copy(tex1,nil,@{x=630,y=700,w=tw,h=th})

                set tex1 = tex where{
                    sfc = (FNT2::renderUtf8("de Point and Click. Ele será","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("de Point and Click. Ele será")
                REN::copy(tex1,nil,@{x=630,y=700+th,w=tw,h=th})

                set tex1 = tex where{
                    sfc = (FNT2::renderUtf8("utilizado para interagir com pistas","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("utilizado para interagir com pistas")
                REN::copy(tex1,nil,@{x=630,y=700+(th*2),w=tw,h=th})

                set tex1 = tex where{
                    sfc = (FNT2::renderUtf8("e se mover pelos vagões do trem","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("e se mover pelos vagões do trem")
                REN::copy(tex1,nil,@{x=630,y=700+(th*3),w=tw,h=th})
            }
            3 =>{
                val img_1 = tex where {
                    sfc = IMG.load("../assets/Wagon_Day.png")
                    tex = REN::createTextureFromSurface(sfc)
                }
                val img_2 = tex where {
                    sfc = IMG.load("../assets/Wagon_Night.png")
                    tex = REN::createTextureFromSurface(sfc)
                }
                val img_3 = tex where {
                    sfc = IMG.load("ghost.png")
                    tex = REN::createTextureFromSurface(sfc)
                }

                REN::copy(img_1,nil,@{x=300,y=300,w=474,h=265})
                REN::copy(img_2,nil,@{x=800,y=300,w=474,h=265})
                REN::copy(img_3,@{x=0,y=0,w=190,h=250},@{x=50,y=20,w=190,h=250})
                REN::copy(img_3,@{x=0,y=250,w=190,h=250},@{x=73,y=550,w=190,h=250})
                REN::copy(img_3,@{x=0,y=250,w=190,h=250},@{x=502,y=60,w=190,h=250})
                REN::copy(img_3,@{x=190,y=0,w=145,h=250},@{x=604,y=628,w=145,h=250})
                REN::copy(img_3,@{x=190,y=250,w=130,h=250},@{x=1260,y=788,w=130,h=250})
                REN::copy(img_3,@{x=335,y=0,w=165,h=250},@{x=1157,y=57,w=165,h=250})
                REN::copy(img_3,@{x=320,y=250,w=180,h=250},@{x=1021,y=640,w=180,h=250})
                REN::fillRect(@{x=724,y=768,w=50,h=50})
            }
            4 => {
                val img_1 = tex where {
                    sfc = IMG.load("../Infinigma-Train.png") --> assert
                    tex = REN::createTextureFromSurface(sfc) --> assert
                }
                val _,_,img_w,img_h = img_1::query()
                var tex1 = tex where{
                    sfc = (FNT2::renderUtf8("DIFERENCIAL ?","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("DIFERENCIAL ?")
                REN::copy(tex1,nil,@{x=500,y=40,w=tw*2,h=th*2})
                REN::copy(img_1,nil,@{x=(1500/2)-(img_w/2),y=(1000/2)-(img_h/2),w=img_w,h=img_h})
                var tex1 = tex where{
                    sfc = (FNT2::renderUtf8("Todas as escolhas levam à roma!","shaded",0xFFFFFF))-->assert
                    tex = REN::createTextureFromSurface(sfc)
                }
                set tw, th = FNT2::sizeText("Todas as escolhas levam à roma!")
                REN::copy(tex1,nil,@{x=50,y=850,w=tw*2,h=th*2})

            }
            
        }
        ;;;
        function M.write (fnt, str, pos)
    local sfc = assert(fnt:renderUtf8(str, "blended", {r=255,g=255,b=255}))
    local tex = assert(M.ren:createTextureFromSurface(sfc))
    M.ren:copy(tex, nil, M.ints(M.rect(pos, totable('w','h',sfc:getSize()))))
end
;;;

    }
}

spawn{
    
    ;;val sound = (MIX.loadWAV("suspense.wav"))
    ;;sound::playChannel(1,-1,-1)
    sdl.play "suspense.wav"
}

do :Done{ 
    val trans = (MIX.loadWAV("trans.wav"))-->assert
    loop{
        val _,k = await(SDL.event.KeyDown)
        match k.name{
            :Left => {
                if slide > 1{
                    set slide = slide-1
                    trans::playChannel(2,-1,1500)

                }
            }
            :Right => {
                if slide < 4{
                    set slide = slide+1
                    trans::playChannel(2,-1,1500)
                }
            }
            :Return =>{
                escape(:Done)
            }
        }
    }
}