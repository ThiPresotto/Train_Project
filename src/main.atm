;;DECLARE

set SDL = require "SDL"
set IMG = require "SDL.image"
set TTF = require "SDL.ttf"
set MIX = require "SDL.mixer"

set sdl = require "atmos.env.sdl"

SDL.init() --> assert
TTF.init() --> assert
IMG.init() --> assert
MIX.init() --> assert

defer {
    TTF.quit()
    SDL.quit()
    IMG.quit()
    MIX.quit()
}

;;INICIALIZANDO

val WIN = SDL.createWindow @{
    title = "Circular train",
    width = 2*474,
    height = 2*265,
    flags = @{SDL.flags.OpenGL}
} -->assert

set REN = SDL.createRenderer(WIN, -1) --> assert
set sdl.ren = REN

val FNT = TTF.open("../assets/tiny.ttf", 40)

MIX.openAudio(44100, SDL.audioFormat.S16, 2, 1024) -->assert;

sdl.play "../assets/trainsound.wav"

val LIGHT = tex where {
    sfc = IMG.load("../assets/Wagon_Day.png") --> assert
    tex = REN::createTextureFromSurface(sfc) --> assert
} 

val DARK = tex where{
    sfc = IMG.load("../assets/Wagon_Night.png") --> assert
    tex = REN::createTextureFromSurface(sfc) --> assert
}

math.randomseed(os.time())
val n_vagao = math.random(3,7)
val trains = @{}

print(n_vagao)
loop i in n_vagao {
    set trains[i] = (math.random(0,1) == 1)
}

xprint(trains)

var index = 1
var resposta = " "
var count = 0

func Trans (t_atual,t_prox){
    var back_seguinte
    var grey_b
    val vagao_a = estado where {
        estado = if (trains[t_atual]) => LIGHT => DARK        
    }
    val vagao_s = estado where{
        estado = if (trains[t_prox]) => LIGHT => DARK
    }
    var back_atual = @{x = 0, y = 0, w = 2*474, h = 2*265}

    if ((t_prox % n_vagao )==((t_atual + 1 ) % n_vagao)){ 
        set back_seguinte = @{x = 1050, y = 0, w = 2*474, h = 2*265}  
        set grey_b = @{x = 958, y = 0, w = 92, h = 2*265} 
    }
    else{
        set back_seguinte = @{x = -1050, y = 0, w = 2*474, h = 2*265}  
        set grey_b = @{x = -92, y = 0, w = 92, h = 2*265} 
    }
    emit('nonTrans',false)

    print("....")
    ;;;
    watching @1{
        val rect = @{x = (2*474)/2, y =(2*265)/2}
            every :sdl.draw{
                REN::setDrawColor(0xFFFFFF)
                sdl.write(FNT,"boo",rect)
            }
    }
    ;;;
    emit('nonTrans',true)
}


func Digitar_Resposta(){
    var count = 0
    watching SDL.event.KeyDown, :Escape {
                        loop{
                            val _, k2 = await(SDL.event.KeyDown)
                            if ((k2.name <= '9')&&(k2.name >= '0')){
                                if (count == 2) {
                                }
                                else{
                                    set resposta = resposta ++ k2.name 
                                    set count = count +1
                                } 
                            }
                            if (k2.name == 'Backspace'){
                                if (count == 0){
                                }
                                else {
                                    set resposta = resposta::sub(1,-2)
                                    set count = count - 1
                                }
                            }
                            if (k2.name == 'Return'){
                                return(resposta)
                            }
                        }
                    }
    set resposta = " "
    return()
}

;;START CODE 



spawn{
    toggle :nonTrans{
        par{    
            every :sdl.draw{
                val rect = @{x = 0, y = 0, w = 2*474, h = 2*265}
                val img = if (trains[index]) => LIGHT => DARK
                REN::copy(img,nil,rect)
            }
        } with {
            val rect = @{x = (2*474)/2, y =(2*265)/2}
            every :sdl.draw{
                REN::setDrawColor(0xFFFFFF)
                sdl.write(FNT,resposta,rect)
            }
        }
    }
}

val resposta = do :Done{
    watching SDL.event.KeyDown, 'X' { ;;Melhor a se fazer com esse "X"?
        loop {
            val _,k = await(SDL.event.KeyDown)
            match k.name {
                :Space => set trains[index] = !trains[index]
                :Right => {
                    val next = ((index)%n_vagao) + 1
                    print(index,'>',next) 
                    Trans(index,next)
                    set index = next
                }
                :Left  => {
                    val next = ((index - 2) % n_vagao) + 1
                    print(index,'>',next) 
                    Trans(index,next)
                    set index = next
                    ;;; Porque quando faço "await Trans" a tela não fica preta
                    (para de desenhar)
                    ;;;
                }
                :Return => {
                    val v = await Digitar_Resposta()
                    if v {
                        escape(:Done, v)
                    }
                }
            }
        }
    }
}


print(resposta++" = resposta")
if (tonumber(resposta) == n_vagao) => print("parabens, vc ganhou") => print("Ih, sabe não")
await @2